#Escreva um programa que peça ao usuário para digitar um número. Trate o erro caso ele digite algo que não seja um número inteiro.
try:
    numero = int(input("Digite um número inteiro: "))
    print(f"Você digitou o número: {numero}")
except ValueError:
    print("Erro: Você não digitou um número inteiro válido.")

#Peça ao usuário dois números e tente multiplicá-los. Se o usuário digitar algo inválido, exiba uma mensagem de erro.
try:
    num1 = int(input("Digite um número: "))
    num2 = int(input("Digite outro número: "))
    resultado = num1*num2
    print("O resultado é: ")
except ValueError:
    print("Erro: Digite números válidos.")

#Crie um programa que peça ao usuário um número inteiro. Se a conversão for bem-sucedida, mostre uma mensagem usando o bloco else.
try:
    num1 = int(input("Digite um número inteiro: "))
except ValueError:
    print("Erro: Você não digitou um número inteiro válido.")
else:
    print(f"Você digitou o número inteiro: {num1}")

#Implemente um programa que abra um arquivo chamado dados.txt (não precisa existir). Use try e finally para garantir que uma mensagem de "Encerrando programa" seja sempre exibida.
try:
    arquivo = open("dados.txt", "r")  # Tenta abrir o arquivo para leitura
    conteudo = arquivo.read()
    print("Conteúdo do arquivo:")
    print(conteudo)
except FileNotFoundError:
    print("Erro: O arquivo 'dados.txt' não foi encontrado.")
finally:
    print("Encerrando programa.")

#Crie uma função dividir(a, b) que lance (raise) uma exceção ZeroDivisionError se b for igual a zero. Caso contrário, retorne o resultado da divisão.
def dividir(a, b):
    if b == 0:
        raise ZeroDivisionError("Erro: divisão por zero não é permitida.")
    return a / b

#Crie uma exceção personalizada chamada IdadeInvalidaError. Depois, crie uma função cadastrar_idade(idade) que lance essa exceção caso a idade seja negativa.
class IdadeInvalidaError(Exception):
    pass
def cadastrar_idade(idade):
    if idade < 0:
        raise IdadeInvalidaError("Idade inválida: não pode ser negativa.")
    print(f"Idade cadastrada: {idade}")

#Peça ao usuário dois números e divida o primeiro pelo segundo. Trate dois tipos de erro: ValueError se o usuário digitar algo inválido ZeroDivisionError se tentar dividir por zero
try:
    num1 = float(input("Digite o primeiro número: "))
    num2 = float(input("Digite o segundo número: "))
    
    resultado = num1 / num2
except ValueError:
    print("Erro: Você deve digitar números válidos.")
except ZeroDivisionError:
    print("Erro: Divisão por zero não é permitida.")
else:
    print(f"O resultado da divisão é: {resultado}")

#Crie um programa que peça ao usuário um número inteiro e verifique se ele é par. Use: try para a conversão, else para verificar se é par ou ímpar,finally para exibir "Fim do programa".
try:
    num = int(input("Digite um número inteiro: "))
except ValueError:
    print("Erro: Entrada inválida. Por favor, digite um número inteiro.")
else:
    if num % 2 == 0:
        print(f"O número {num} é par.")
    else:
        print(f"O número {num} é ímpar.")
finally:
    print("Fim do programa.")

#Crie uma função sacar(saldo, valor) que: Lance (raise) uma exceção personalizada SaldoInsuficienteError se o valor for maior que o saldo.Caso contrário, retorne o novo saldo. Teste a função dentro de um try-except e exiba uma mensagem apropriada ao usuário.
class SaldoInsuficienteError(Exception):
    pass
def sacar(saldo, valor):
    if valor > saldo:
        raise SaldoInsuficienteError("Erro: saldo insuficiente para realizar o saque.")
    return saldo - valor
try:
    saldo_atual = 1000
    valor_saque = float(input("Digite o valor que deseja sacar: "))
    novo_saldo = sacar(saldo_atual, valor_saque)
except SaldoInsuficienteError as e:
    print(e)
else:
    print(f"Saque realizado com sucesso! Novo saldo: R$ {novo_saldo:.2f}")
